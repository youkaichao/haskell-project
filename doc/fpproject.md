# 函数式语言程序设计 2019 课程作业（征求意见稿）

## 简介

本次作业选题为 “编程语言的解释器的实现” 。

本文档为征求意见稿。请同学们近几天看一看想一想，通过邮件、微信群等方式提出意见建议。2019-05-13 上课时我们会讲解其中内容、综合大家意见；课后给出课程作业的需求。

## 完成方式

本作业允许组队完成，规模为1~3 人。作业提交内容包括：
1. 项目全部源代码；
2. 实验报告（内容包括但不限于：(1) 提交代码的执行方法描述，(2) 作业的实现目标(实现了哪些语言特性、语言定义是怎样的、实现了哪些得分项)，(3) 作业的实现思路与亮点，(4) 挑战与解决方案、参考资料或参考代码等）；
3. 每位成员在作业中的贡献（请用一个另外的文档简要说明）。

本作业的截止时间为 __第 18 周周日__ ，请按时提交作业，否则会影响成绩的录入。本学期毕业的同学需要更早提交（第 16 周）。实现选做内容的同学需要给助教展示验收，详见后文“评测方式”。

## 作业内容

本作业的内容是一个语言的解释器（interpreter）。该语言是一个基于简单类型 lambda 演算（simply typed lambda calculus）的微型的语言。本作业和编译原理课通常做的语言实现作业不太一样。编译原理课通常会用 BNF 给出要实现的语言的具体文法，例如：
```
expression
  ::= True
    | False
    | (not expression)
    | (and expression expression)
    | (or expression expression)
```
然后由你来 parse 成解析树（parsing tree、CST），然后转换成某种形式的抽象语法树（AST），然后从 AST 去解释执行（如果是做解释器），或编译到某种目标语言（如果是做编译器）。

但本作业不一样。我们会提供一个使用 Haskell 的数据类型来定义的抽象语法树（AST），见 `AST.hs` 以及其生成的文档 `doc/haddock/AST.html`，其中给出了 AST 的每种形式的求值规则和类型规则（typing rule）。

你需要做的是（更详细的内容包括 __评分标准__ 请参考“语言特性得分项目”部分）：

1. 必做部分：核心语言（80 分）
   1. 写一个 `evalType` 函数，求该 AST 的实例的类型；
   2. 写一个 `evalValue` 函数，对该 AST 的实例求值；
2. 选做部分
   1. 实现代数数据类型（ADT）的支持：包括代数数据类型的声明、构造函数、模式匹配语句的支持（20 分）；
   2. 为这个语言设计一个具体文法，并写一个 parser，它能把符合你的具体文法的字符串 parse 到该 AST（20 分）；
   3. 基于具体文法，实现一个 `REPL`（20 分）；
   4. 实现编译器（40 分）。

每位同学必做部分 + 选做部分的总分不超过 110 分。对于组队的同学，必做部分的得分每位同学相同，选做部分的得分由组员均摊。例如：

+ 3 位同学组队，必做部分得到 75 分，正确实现了共 80 分的选做项目，则每人的课程作业得分为 min(110, 75 + (80/3)) = min(110, 75 + 26.7) = min(110, 101.7) = 101.7；
+ 1 位同学单独成队，必做部分得到 70 分，选做项目得到 45 分，则课程作业得分为 min(110, 70 + 45) = min(110, 115) = 110。

如果你希望实现不在以上列表的选做内容，请联系助教获得许可。

## 语言特性得分项目

### 核心语言：必做

包括 `AST.hs` 中：
1. 类型： `Type` 类型中的 `TBool` 、 `TInt` 、 `TChar` 、`TArrow` 的支持，分别对应布尔类型、整数类型、字符类型、函数类型(包括高阶函数)；
2. 表达式： `Expr` 类型中的 `EBoolLit` 、 `EIntLit` 、 `ECharLit` 、 `ENot` 、 `EAnd` 、 `EOr` 、 `EAdd` 、 `ESub` 、 `EMul` 、 `EDiv` 、 `EEq` 、 `ENeq` 、 `ELe` 、 `EGt` 、 `ELeEq` 、 `EGtEq` 、 `EIf` 、 `ELambda` 、 `ELet` 、 `ELetFun` 、 `EVar` 、 `EApply`，即除去 `ECase` 的所有 `Expr` 。

不需要支持 `ADT` ，即 `Program` 的形式为 `Program [] <some expression>` 。

注意：
1. `ELambda` 无法进行递归， `ELetFun` 允许递归，所以你的实现需要支持递归；

2. 函数是 currying 的，所以你的实现需要支持高阶函数。

3. `evalType` 的类型是 `Program -> Maybe Type`。当参数代表的表达式有类型错误时，返回 `Nothing`；否则返回 `Just 该表达式的类型`。

   `evalValue` 的类型是 `Program -> Result`。返回参数代表的表达式的求值结果。

4. `src/` 下的 `EvalType.hs` 和 `EvalValue.hs` 提供了一种实现方式，供参考。你可以用它的方式来实现（其中用到后面课程要讲的 `MonadTransformer`），或用你自己的方式实现。`test/Spec.hs` 提供了一些测试用例，你可以读代码和用 `stack test` 正常执行其中两个 case。

评分方法：会提供 80 个样例 `AST` 实例测试 `evalType` 和 `evalValue` 函数，并有 20 个隐藏测试点，最终得分按照这 100 个测试点的得分确定。这些测试点不会纠结在一些细节上，例如不会考虑除数为 0 时的行为、不会考虑命名冲突时的行为等等。

### 代数数据类型：选做

需要在 `evalType` 和 `evalValue` 中完整实现对 `AST.hs` 中的 `Type` 、 `Expr` 和 `Pattern` 的支持，评分时有对于这两个函数的黑盒测试。如果思考得比较清楚，该选做项工作量相对同分值的其他选项会小一些。

### 文法设计和 parser：选做

需要提供可以 parse 出一些给定的 test case 的字符串用于黑盒测试。可以参考 Lisp 系方言的语法并增加自己设计的类型标注（Lisp 系容易 parse）。核心语言中去掉了很多常见语言中的常见语法糖，因此文法设计和 parser 层面可以实现一些语法糖，例如支持在单个 let 语句中进行多个绑定、支持在 let 语句中使用模式匹配等等。

最终评分时我们会提供若干个合法的 `AST` ，你需要构造一些符合你设计的文法的程序（字符串），使得它们经过你的 parser 后可以得到这些 `AST` 。

<!--或者说能给出某些ast的字符串有15分，剩下五分看展示效果？--> 

### REPL：选做

类似 `ghci` ，支持表达式值打印和表达式类型查看等。

### 实现编译器：选做

把合法的 AST 编译到某种目标代码。可以编译至 `Java Bytecode` 、 `LLVM IR` 、 `GIMPLE` 或 `JavaScript` 。

## 评测方式

本作业的评测方法为黑盒 + 白盒 + 手动测试。即通过以下方面进行详细评分：

1. 提交的实现首先会经过基本的测试用例测试；
2. 提交的实现会经过边界值等特殊情况测试；
3. 所提交实现的性能优化和代码风格等均会考察和予以评分。

执行环境为 GHC 8.6.4，允许使用所有 GHC 扩展和 ghc boot libraries (GHC 自带库)。鼓励使用 `stack` 进行项目管理。使用第三方库需要提前向助教确认并获得批准。

### 展示环节

做了选做部分的同学，需要在第 16 周的某个时间（待定）或第 18 周的某个时间（待定），给助教集中展示验收，以充分体现你所实现的功能。